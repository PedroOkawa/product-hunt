package greendao;

import greendao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here

import com.google.gson.annotations.SerializedName;
// KEEP INCLUDES END
/**
 * Entity mapped to table "VOTE".
 */
public class Vote {

    // KEEP FIELDS - put your custom fields here

    private Long id;
    @SerializedName("user_id")
    private Long userId;
    @SerializedName("created_at")
    private java.util.Date createdAt;
    private java.util.Date updateDate;
    @SerializedName("post_id")
    private Long postId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient VoteDao myDao;

    private User user;
    private Long user__resolvedKey;
    // KEEP FIELDS END

    public Vote() {
    }

    public Vote(Long id) {
        this.id = id;
    }

    public Vote(Long id, Long userId, java.util.Date createdAt, java.util.Date updateDate, Long postId) {
        this.id = id;
        this.userId = userId;
        this.createdAt = createdAt;
        this.updateDate = updateDate;
        this.postId = postId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getVoteDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    public java.util.Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(java.util.Date createdAt) {
        this.createdAt = createdAt;
    }

    public java.util.Date getUpdateDate() {
        return updateDate;
    }

    public void setUpdateDate(java.util.Date updateDate) {
        this.updateDate = updateDate;
    }

    public Long getPostId() {
        return postId;
    }

    public void setPostId(Long postId) {
        this.postId = postId;
    }

    /** To-one relationship, resolved on first access. */
    public User getUser() {
        Long __key = this.userId;
        if (user__resolvedKey == null || !user__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User userNew = targetDao.load(__key);
            synchronized (this) {
                user = userNew;
            	user__resolvedKey = __key;
            }
        }
        return user;
    }

    public void setUser(User user) {
        synchronized (this) {
            this.user = user;
            userId = user == null ? null : user.getId();
            user__resolvedKey = userId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here

    public void sync() {
        setUser(user);
        getUser().sync();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Vote vote = (Vote) o;

        if (id != null ? !id.equals(vote.id) : vote.id != null) return false;
        if (userId != null ? !userId.equals(vote.userId) : vote.userId != null) return false;
        if (createdAt != null ? !createdAt.equals(vote.createdAt) : vote.createdAt != null)
            return false;
        if (updateDate != null ? !updateDate.equals(vote.updateDate) : vote.updateDate != null)
            return false;
        if (postId != null ? !postId.equals(vote.postId) : vote.postId != null) return false;
        if (daoSession != null ? !daoSession.equals(vote.daoSession) : vote.daoSession != null)
            return false;
        if (myDao != null ? !myDao.equals(vote.myDao) : vote.myDao != null) return false;
        if (user != null ? !user.equals(vote.user) : vote.user != null) return false;
        return !(user__resolvedKey != null ? !user__resolvedKey.equals(vote.user__resolvedKey) : vote.user__resolvedKey != null);

    }

    @Override
    public int hashCode() {
        int result = id != null ? id.hashCode() : 0;
        result = 31 * result + (userId != null ? userId.hashCode() : 0);
        result = 31 * result + (createdAt != null ? createdAt.hashCode() : 0);
        result = 31 * result + (updateDate != null ? updateDate.hashCode() : 0);
        result = 31 * result + (postId != null ? postId.hashCode() : 0);
        result = 31 * result + (daoSession != null ? daoSession.hashCode() : 0);
        result = 31 * result + (myDao != null ? myDao.hashCode() : 0);
        result = 31 * result + (user != null ? user.hashCode() : 0);
        result = 31 * result + (user__resolvedKey != null ? user__resolvedKey.hashCode() : 0);
        return result;
    }

    // KEEP METHODS END

}
